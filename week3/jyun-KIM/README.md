# 주제

테라폼 모듈의 이해, 활용 및 커스텀 모듈 제작 방법론

# 요약

테라폼 모듈은 리소스를 패키징하고 재사용하는 핵심 방법이며 , 모듈의 종류(루트, 하위)와 기본적인 사용법을 정리했다. 또한, 인프라 리소스 생성 없이 로직을 중앙화하는 유틸리티 모듈의 개념과 활용 사례(AWS 메타데이터 조회, 맵 합치기 등)를 다루었다. 마지막으로, 공개 모듈의 한계를 인식하고 조직의 요구사항에 맞는 커스텀 모듈을 직접 제작하는 구체적인 5단계 방법론을 제시한다

# 학습 내용

## 1. 테라폼 모듈의 기본 개념 및 사용

### 1.1 모듈의 종류 및 구조

- **테라폼 모듈**은 여러 테라폼 구성 파일을 하나의 디렉터리에 모아 리소스를 패키징하고 재사용하는 주된 방법이다.
- **루트 모듈 (Root Module)**: 테라폼 초기화가 되어 있어 테라폼 명령을 실행할 수 있는 디렉터리이다.
- **하위 모듈 (Child Module)**: 루트 모듈에서 사용되는 모듈로, 커스텀 모듈이나 공개 모듈(published module) 등이 있다.
- **관습적인 기본 구조**: 모듈 작성 시 `main.tf`(엔트리 포인트), `variables.tf`(입력 변수), `outputs.tf`(출력값), `locals.tf`(로컬 변수)를 사용하는 것이 일반적이다.

### 1.2 모듈 호출 및 메타인수

- 모듈을 호출한다는 것은 모듈에서 정의한 변수의 값을 입력하여 그 값에 따라 조정된 모듈의 리소스를 루트 모듈에 포함하는 것이다.
- **`source`**: 사용할 모듈의 경로를 지정하는 메타인수이다 (예: 로컬 디렉터리 `./ec2-asg`, 원격 저장소 `github.com/user/repo`).
- **`version`**: 공개 모듈 사용 시 버전을 지정한다. `~> 5.8.1`과 같은 **비관적 제약 조건**을 사용하면 마이너 버전은 유지하며 패치 버전 업데이트만 허용한다.
- **`providers`**: 테라폼 프로바이더 설정을 하위 모듈로 넘겨주는 역할을 한다. 맵 타입의 값을 받으며, 루트 모듈에서 에일리어스(`alias`)로 정의된 프로바이더를 하위 모듈의 프로바이더에 매핑하여 전달할 수 있다.

## 2. 유틸리티 모듈의 활용

- **유틸리티 모듈 (Utility Module)**: 인프라 리소스가 반환값이나 사이드 이펙트의 대상이 아닌 모듈로 , 로직의 중복을 최소화하고 가독성을 높인다.
- **AWS 메타데이터 조회**: `get_aws_metadata` 모듈을 만들어 여러 데이터 블록(`aws_caller_identity`, `aws_region` 등)을 한 번에 호출하고, 필요한 메타데이터 값(예: `account_id`, `region_name`)을 출력값으로 받아올 수 있다.
- **프로바이더 동일성 체크**: `check_aws_cross_provider` 모듈을 통해 두 프로바이더의 계정 또는 리전이 동일한지 확인하고 (`is_cross_account`, `is_cross_region`), 이를 VPC 피어링 같은 인프라 조작 시 분기 처리 로직에 활용할 수 있다.
- **리스트 내 맵 합치기**: 각 항목이 맵인 리스트를 단일 맵으로 통합하는 `merge_map_in_list` 모듈을 정의하여 , `keys()`, `values()`, `flatten()`, `zipmap()`을 조합하는 복잡한 표현식의 재사용성을 확보한다.

## 3. 커스텀 모듈 직접 제작 방법론

공개 모듈은 범용적 사용 사례에 맞춰 복잡하며 , 조직의 고유 요구사항(보안 정책, 태그 정책 등)을 반영하기 어렵다는 한계가 있다. 따라서 직접 만든 모듈은 맞춤형 설계와 유지 관리가 용이하다.

### 3.1 모듈 제작 5단계

1. **요구사항 정리 및 입력값 정하기**:
   - 테라폼으로 만들고 관리할 리소스에 대한 요구사항을 정리한다.
   - 운영 시 리소스 상태를 변경하거나 생성할 입력값을 결정한다. (예: 레디스 캐시 모듈의 경우 `Name`, `Env` 태그 강제 포함, 특정 포트만 허용 등) .
2. **입력값을 모듈에 전달할 방법 정하기**:
   - 입력 파일을 어떤 방식으로 모듈에 전달할지 (예: 단일 YAML 파일, 특정 폴더 내 다중 YAML 파일) 고민한다.
   - 다중 환경에서 반복을 어떻게 수행할지 정의한다 (예: VPC별 모듈 반복 호출).
3. **모듈 만들기**:
   - **변수 임시 설정**: 모듈 작성 초기에는 변수 블록에 `name`, `attribute` 등 큰 틀의 정보만 임시로 설정한다.
   - **모듈 속 공통 태그 설정**: 모듈 내에서 공통으로 사용할 태그를 미리 선언하여 모든 리소스에 쉽게 적용한다.
   - **실제 리소스 블록 선언**: 필요한 로직에 맞게 리소스 블록을 선언한다 (예: `aws_elasticache_replication_group`).
4. **유효성 검사**:
   - **변수 타입 유효성**: 임시 설정된 변수 블록에 `string`, `list(string)` 등 구체적인 타입을 지정한다.
   - **입력값 유효성**: `validation` 블록과 `precondition` 블록을 사용하여 입력값 제한 요구사항을 달성한다.
5. **모듈 출력 설정**:
   - 모듈에서 생성된 리소스에서 파생되는 출력값(예: 아이디, DNS 주소)을 외부에서 참조할 수 있도록 `output` 블록을 선언한다.

# 추가

**주제**
Immutable Infrastructure (불변 인프라)의 개념 및 중요성

**요약**
**불변 인프라(Immutable Infrastructure)**는 배포 후에는 수정되지 않고 변경이 필요할 경우 기존 인프라를 폐기하고 새로운 인프라로 교체하는 방식의 인프라 관리 모델이다. 이 모델은 **구성 드리프트(Configuration Drift)**를 방지하고, **배포의 안정성과 예측 가능성**을 높이며, **롤백을 단순화**하는 핵심 이점을 제공한다3. 현대 클라우드 환경과 컨테이너 기술(Docker, Kubernetes)에 필수적인 개념이다

**학습 내용**
**1. Immutable Infrastructure의 정의 및 특징**
**1.1 정의**

• **불변 인프라(Immutable Infrastructure)**란 인프라 컴포넌트(서버, 컨테이너 등)가 한 번 생성되고 배포되면 그 이후에는 **절대 변경되지 않는** 관리 방식이다

• 인프라를 업데이트하거나 수정해야 할 때, 기존 컴포넌트를 직접 **수정하는 대신**, 기존 컴포넌트를 **폐기(destroy)**하고 미리 새로운 설정이 적용된 **새로운 컴포넌트(replace)**를 만들어 배포한다

**1.2 Mutable (가변) 인프라와의 비교**
**특징Mutable Infrastructure (가변 인프라)Immutable Infrastructure (불변 인프라)관리 방식**배포 후에도 서버에 로그인하여 패치, 설정 변경, 업데이트 등 **직접 수정**이 가능하다
배포 후 수정은 금지되며, 변경 시 **새로운 이미지**를 빌드하여 기존 인프라를 **교체**한다

**문제점**
**구성 드리프트(Configuration Drift)** 발생 가능성이 높다
구성 드리프트가 원천적으로 방지된다
**배포 단위**개별 서버나 컴포넌트의 설정 파일

**완전히 새로 빌드된 이미지** (예: AMI, Docker Image)

**2. 핵심 이점 (Why Immutable?)**

**2.1 구성 드리프트 (Configuration Drift) 방지**

- **구성 드리프트**는 시간이 지남에 따라 인프라 환경의 구성 상태가 최초 정의된 상태와 달라지는 현상을 의미한다
- 가변 인프라에서는 서버를 수동으로 수정하거나 자동화되지 않은 스크립트가 실행되면서 특정 서버만 다른 설정을 가지게 될 위험이 있다
- 불변 인프라 모델에서는 모든 변경 사항이 새로운 이미지 빌드 프로세스를 통해 적용되므로, 모든 인스턴스는 동일한 **기준 이미지(Golden Image)**에서 시작하여 **일관성**이 보장된다15.

**2.2 배포의 안정성 및 예측 가능성 증대**

- 모든 배포는 동일한 빌드 프로세스(파이프라인)를 거친 새로운 이미지로 이루어지므로, 인프라의 상태를 **예측하기 쉽고** 테스트된 환경과 **동일한 상태**로 프로덕션에 배포된다
- 새로운 배포가 실패하더라도, 문제가 발생한 인스턴스는 즉시 폐기되므로 **장애 전파 위험이 낮다**

**2.3 단순하고 빠른 롤백**

- 불변 인프라에서는 문제가 발생했을 경우, 이전 배포 상태로 돌아가는 롤백(Rollback) 과정이 매우 단순하다
- 기존 인프라를 **수정할 필요 없이**, 이전에 성공적으로 배포되었던 **옛날 버전의 이미지**를 사용하여 인프라를 **새로 배포(교체)**하기만 하면 된다19. 이 과정은 매우 빠르고 안전하다

**3. 구현 기술 및 도구**

**3.1 이미지 빌드 (Image Building)**

- 인프라를 불변하게 만드는 핵심 단계는 배포할 인프라의 모든 설정(OS, 패치, 애플리케이션 등)을 포함하는 **이미지(Image)**를 만드는 것이다
- **Packer**: 서버 이미지(AWS AMI, Azure VHD 등)를 자동화하여 생성하는 데 널리 사용된다
- **Docker**: 애플리케이션과 그 종속성을 컨테이너 이미지로 묶어 불변성을 확보하는 가장 대표적인 기술이다23.

**3.2 배포 및 교체 (Deployment & Replacement)**

- 기존 인프라를 새로운 인프라로 안전하게 교체하는 배포 전략이 필요하다
- **블루/그린 (Blue/Green Deployment)**: 현재 서비스 중인 환경(Blue)과 동일한 새로운 환경(Green)을 구축한 후, 트래픽을 한 번에 Green으로 전환하는 방식
- **카나리 (Canary Deployment)**: 새로운 인프라를 소수의 사용자에게만 먼저 배포하여 검증한 후, 점진적으로 트래픽을 늘려가는 방식
- **테라폼 (Terraform)**: 인프라 자체를 코드로 정의(IaC)하며, 변경 시 기존 리소스를 `destroy`하고 새 리소스를 `create`하도록 설계할 수 있어 불변 인프라를 관리하는 데 강력한 도구로 사용된다
