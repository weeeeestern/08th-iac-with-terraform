# 주제

> IaC 개념과 등장 배경, Terraform의 구성 요소와 동작 원리

# 요약

* **IaC(Infrastructure as Code)**는 수동 인프라 관리의 한계(인적 오류, 설정 드리프트)를 극복하기 위해, 인프라를 코드로 정의하고 관리하는 방식입니다.
* **Terraform**은 HCL(구성 파일)을 사용하는 대표적인 IaC 도구로, **Core**(엔진), **Provider**(API 통신), **State 파일**(현상태)로 구성됩니다.
* Terraform은 `init`(준비), `plan`(계획 비교), `apply`(실제 적용)의 3단계 워크플로우를 통해 코드(설계도)와 실제 인프라 상태를 일치시킵니다.

# 학습 내용

## A. IaC 개념과 등장 배경

### 1. IaC (Infrastructure as Code) 개념

> 인프라스트럭처를 **코드를 통해 정의하고 관리**하는 IT 운영 방식입니다. 

- 관리자가 직접 서버에 접속하거나 그래픽 사용자 인터페이스(GUI) 콘솔을 클릭하여 인프라(서버, 네트워크, 데이터베이스 등)를 설정
- => **설정 파일(코드)**로 작성 후 인프라 환경에 적용

#### 장점

- 애플리케이션 소스 코드처럼 취급할 수 있다 ()= git을 통한 코드관리가 가능하다)
  - 변경 이력 추적
  - 동료 검토(Code Review)
  - 자동화 (테스트 및 배포 파이프라인)

### 2. 등장 배경: 전통적 인프라 관리의 한계

> 수동 인프라 관리가 가진 문제점들을 해결하기 위해 등장

#### 가. 수동 작업의 비효율성과 인적 오류
: 인프라를 준비(프로비저닝)하기 위해 관리자가 직접 장비를 주문, 설치하거나 클라우드 콘솔에서 수많은 항목을 클릭

- 시간이 오래 걸림
- 반복적 작업
- 높은 인적 오류 발생 가능성

#### 나. 환경 간 불일치 (설정 드리프트)
: 개발, 스테이징, 프로덕션 환경의 불일치 가능성 (시간 경과에 따라 미세한 차이 발생)

- => "설정 드리프트(Configuration Drift)" (개발 환경에서는 문제가 없었는데, 프로덕션 환경에서는 장애가 발생하는 현상)

#### 다. 확장성 및 복구의 어려움
: 변화의 신속대응 어려움

- **확장(Scale-out):** 트래픽이 몰려 서버 100대를 즉시 증설해야 할 때, 수동으로는 신속한 대응이 불가능
- **복구(Recovery):** 장애로 인해 시스템이 다운되었을 때, 이전과 동일한 상태로 인프라를 복구하는 데 많은 시간과 노력이 필요

### 3. 해결책: 자동화와 일관성의 필요성

- 클라우드 서비스(AWS, GCP, Azure 등)의 보편화 => API를 통한 인프라 제어가 가능해짐
- DevOps 문화의 확산 => 인프라 배포 역시 소프트웨어 개발처럼 빠르고 안정적이어야 한다는 요구 증가

=> IaC: 인프라 구성의 코드화를 통한 **자동화(Automation)**, **일관성(Consistency)**, **재현성(Reproducibility)** 확보의 핵심 해결책으로 등장



## B. Terraform의 구성 요소와 동작 원리

> IaC를 구현하는 도구. HCL(HashiCorp Configuration Language) 기반 인프라 정의 및 적용

### 1. 주요 구성 요소

* **A. Terraform Core:**
  - Terraform의 실행 파일(`terraform`) 자체
  - "무엇을" 만들지 결정
  - 구성 파일(HCL)을 읽고 해석
  - 인프라의 '상태(State)'를 관리
  - 리소스 간의 의존성을 분석하고 실행 계획(Plan)을 생성

* **B. Providers:**
  - 특정 플랫폼의 API와 통신하는 플러그인 (AWS, GCP, NCP 등)
  - "어떻게" 만들지 결정
  - 실제 CSP API Call 수행

* **C. Configuration Files (.tf):**
  - 사용자가 HCL을 사용하여 '어떤 인프라를 원하는지'를 **선언적**으로 정의하는 텍스트 파일
  - 설계도 역할

* **D. State File (terraform.tfstate):**
  - Terraform이 **실제로 생성하고 관리 중인 인프라의 상태**를 JSON 형식으로 저장하는 파일
  - '설계도(코드)'와 '실제 인프라' 사이의 매핑 정보 역할
  - Terrafor이 변경 사항을 계산하는 기준

---

### 2. 동작 원리

> Terraform Core'를 중심으로 '구성 파일(Code)', 'State 파일', 'Provider'가 상호작용하며 3단계(Init, Plan, Apply)로 진행

#### 1. `init`: 작업 환경 준비
: 'Core'가 '구성 파일(.tf)'을 스캔

1.  Core → 구성 파일: tf 파일을 훑어보며 어떤 Provider가 필요한지(예: `required_providers = { aws = ... }`) 확인
2.  Core → Provider: 필요한 Provider 플러그인을 인터넷 레지스트리에서 다운로드
3.  Core → State 파일: State 파일을 기록할 위치(Backend)를 설정하고 준비

---

#### 2. `plan` 단계: 변경 계획 수립

> 'Core'가 tf파일과 실제 적용환경의 차이를 비교하여 Execution Plan을 생성

1.  Core → 구성 파일: 사용자가 원하는 목표 상태를 확인
2.  Core → State 파일: 기록된 현재 상태를 조회
3.  Core → Provider → 실제 인프라: Provider를 통해 state 파일에 기록된 내용이 실제 인프라와 일치하는지(Drift) 확인
4.  Core: tf 파일과 state를 비교하여 생성(Create), 수정(Update), 파괴(Destroy)가 필요한 작업 목록을 정리 후 출력

---

#### 3. `apply` 단계: 실제 인프라 적용

> 'Core'가 'plan' 단계에서 수립한 계획을 실행

1.  Core → Provider: Plan의 내용을 의존성 순서에 따라 Provider에 전달
2.  Provider → 실제 인프라 (API): 실제 클라우드 API를 호출하여 리소스를 생성, 수정, 또는 삭제
3.  Provider → Core: 작업 결과를 'Core'에게 보고
4.  Core → State 파일: 변경된 최종 결과를(예: 새로 생성된 인스턴스 ID) State 파일에 정확히 기록

### 3. 주요 명령어

#### 가. `terraform init` (초기화)
: 작업 환경을 준비

- 구성 파일(`.tf`)을 스캔 -> 필요한 Provider 플러그인을 다운로드
- State File을 저장할 백엔드(Backend)를 설정

#### 나. `terraform plan` (계획)
: 변경 사항을 예측하는 가상실행 단계

- '설계도(코드)'와 '현장 관리 대장(State File)' 비교
- 필요한 경우 실제 클라우드 API를 조회하여 현재 인프라 상태(Drift)를 확인
- 어떤 리소스가 생성(Create), 수정(Update), 또는 삭제(Destroy)될지 상세한 '실행 계획'을 표시

#### 다. `terraform apply` (적용)
: `plan` 단계에서 생성된 '실행 계획'을 실제로 실행

- 코드에 기술된 변경사항을 클라우드 환경에 적용하기 위해, Provider가 클라우드 API를 호출하여 인프라를 생성, 수정, 삭제
- 모든 작업이 성공적으로 완료되면, **'현장 관리 대장(State File)'을 최신 상태로 업데이트**합니다.

#### 라. `terraform destroy` (제거)
: `apply`와 반대; tf파일의 설계와 무관하게 State File에 기록된 모든 리소스를 삭제